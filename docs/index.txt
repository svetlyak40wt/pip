Poach Eggs
==========

.. toctree::

   requirement-format
   news
   license

Introduction
------------

This script installs a set of packages at once using
``easy_install``.  It improves on the output of easy_install and also
allows you to define a set of working packages, separately from the
exact requirements of the packages themselves.

This package works best when used together with `virtualenv
<http://pypi.python.org/pypi/virtualenv>`_.  Together they will allow
you to create repeatable and reliable deployments.

The Idea
--------

When installing software, and Python packages in particular, it's
common that you get a lot of libraries installed.  You just did
``easy_install MyPackage`` and you get a dozen packages.  Each of
these packages has its own version.

Maybe you ran that installation and it works.  Great!  Will it keep
working?  Did you have to provide special options to ``easy_install``
to get it to find everything?  Did you have to install a bunch of
other optional pieces?  Most of all, will you be able to do it again?

If you've ever tried to setup an application on a new system, or with
slightly updated pieces, and had it fail, PoachEggs is for you.  If
you haven't had this problem then you will eventually, so PoachEggs is
for you too.  PoachEggs is a tool to make explicit, repeatable
installation of packages.

What Does It Do?
----------------

What PoachEggs does is really simple: it installs a list of packages.
It actually installs them all with easy_install.

The list of packages is called a "requirements file".  It has one
requirement per line.  It might look like::

    -e http://someproject.org/svn/someproject/trunk@2014#egg=SomeProject
    SomeLibrary==0.3
    SomeOtherLibrary>=1.2dev
    -f http://someproject.org/dependencies.html

The first line tells PoachEggs to check out the svn repository
``http://someproject.org/svn/someproject/trunk``, revision 2014, and
install it.  The libraries SomeLibrary (version 0.3) and
SomeOtherLibrary (version 1.2dev or higher) are also installed.  Also
``easy_install`` will look on the page
``http://someproject.org/dependencies.html`` for the requirements.

This file can live in version control somewhere, and everyone can use
it as the basis for their work.

But this alone isn't enough to make the installations reliable.  Let's
say SomeLibrary depends on SomePackage (which isn't listed in our
requirements file), and the most recent version of SomePackage happens
to be 1.4.  Then SomePackage 1.5 comes out.  Maybe it works fine with
SomeLibrary, or maybe it doesn't, but as a whole it breaks something.
Maybe it's not a big deal, but it's not something you really want to
deal with -- neither of those libraries is yours.

Once you have a working setup, you can run::

    $ poacheggs --freeze=frozen-requirements.txt

and it'll write out the *exact* versions of everything that is
installed.  It might look like this::

    -e http://someproject.org/svn/someproject/trunk@2014#egg=SomeProject
    SomeLibrary==0.3
    SomeOtherLibrary==1.4.5
    SomePackage==1.4
    -e http://someproject.org/svn/mylib/trunk@2095#egg=MyLib-0.1dev-r2095
    -f http://someproject.org/dependencies.html

You'll notice it adds in libraries that might be second-order
requirements.  Also if it sees packages with versions like
``0.1dev-r2095`` it guesses that it's from an svn checkout, and it
tries to find that checkout.

This file will reliably create the same environment at a later date or
on another computer.  You can also use this as a starting point for
development -- for instance, maybe you remove the ``@2014`` from the
SomeProject requirement, running from trunk.  Then everything else is
pinned (unless you also unpin some other pieces) except for the single
package you are developing.

Using PoachEggs with virtualenv
-------------------------------

PoachEggs is really meant to be used with `virtualenv
<http://pypi.python.org/pypi/virtualenv>`_.  Virtualenv is a tool to
build isolated Python environments.  These environments have their own
list of installed packages, and are isolated from other environments
on the system and to a degree they are isolated from the packages
installed globally on the system.  Without using virtualenv you won't
even have a chance at creating repeatable installations; as such, it
is *highly* recommended that you use it.

You can run PoachEggs inside a virtualenv environment without installing it into
that environment.  You can do it like::

    $ poacheggs -E some-environment -r requirements.txt

Collecting Eggs and Using Those Eggs
------------------------------------

Instead of installing the eggs you need, you can collect them into a
cache directory.  You do this like::

    $ poach-eggs --egg-cache=./egg-cache --collect -r requirements.txt

this installs all the eggs into ``./egg-cache``, and then you can use
them like::

    $ poach-eggs --egg-cache=./egg-cache --cache-only -r requirements.txt

this way you can avoid problems associated with intermittent networks.
However, this doesn't work with constructing environments that include
svn checkouts that you'll continue editing, as it doesn't keep svn
metadata.

Installing PoachEggs
--------------------

You can install PoachEggs with ``easy_install PoachEggs``, but you can
also just grab `poacheggs.py
<https://svn.openplans.org/svn/PoachEggs/trunk/poacheggs.py>`_ and run
it directly.  This is meant to solve the installation chicken-and-egg
problem -- at least the installation tools shouldn't require much
installation.  Virtualenv similarly can be run from a single
`virtualenv.py
<http://svn.colorstudy.com/virtualenv/trunk/virtualenv.py>`_ file.
